# Proper Error Handling

Like any programming language, error handling in Bash ensures a program functions as intended. Proper error handling ensures a script behaves predictably, provides useful feedback, and avoids unexpected behaviors.

This section covers essential practices for handling errors in Bash, such as checking for command success, using `trap` for signal handling, redirecting errors to `stderr`, and understanding `set -e`.

## Checking Command Success

Commands like `cd`, `rm`, and `mv` can fail for various reasons, such as incorrect paths, insufficient permissions, or missing files. Failing to check the success of these commands can result in deleting the wrong files or modifying the wrong directories.

/// admonition | Guidelines
    type: info
//// tab | Conditional Checks

- **Usage**: <mark>**_ALWAYS_**</mark> follow commands whose potential to fail could cause problems for the rest of the script with a conditional check.

///// admonition | Example
    type: example

```bash
cd /some/path || exit 1
rm file
```

/////
////
//// tab | Error Messages for Clarity

- **Guideline**: When a command fails, provide a clear error message to indicate what went wrong.

///// admonition | Example
    type: example

```bash
cd /some/path || { echo "Failed to change directory" && exit 1 }
rm file
```

/////
////
///

## Using `trap` for Signal Handling

Signal handling in Bash involves capturing and responding to signals sent to the script. Signals can be generated by the system or user actions, such as pressing ++ctrl+'C'++ to interrupt a script or sending a termination signal with the `kill` command.

/// admonition | Guidelines
    type: info
//// tab | Cleanup Operations

- **Usage**: Use `trap` to define cleanup operations or other necessary actions that should occur before a script exits.
- **Reason**: Without `trap`, ensuring that files or other resources are properly cleaned up before the script exits can be challenging. This is especially important when an unexpected error occurs, resulting in a premature script termination.

///// admonition | Example
    type: example

_Using `trap` to remove a temporary file when the script exits:_

```bash
TMP_FILE=$(mktemp)

trap 'rm -f "$TMP_FILE"' EXIT

echo "Temporary file created: $TMP_FILE"
echo "Random data" > "$TMP_FILE"
exit 0
```

/////
////
//// tab | Functions for Complex Trapping Logic

- **Guideline**: For more complex signal handling, define a function that performs all necessary actions and then invoke this function in your `trap` command.
- **Reason**: Functions help keep your trapping logic organized and manageable, especially when dealing with multiple signals or complex tasks.

///// admonition | Example
    type: example

_Defining a cleanup function and using it with `trap`:_

```bash
TMP_FILE=$(mktemp)

cleanup() {
    if (( $1 == 0 )); then
        echo "[INFO]  Exiting normally"
    else
        echo "[ERROR] An error occurred" >&2
    fi

    echo "[INFO]  Cleaning up..."
    rm -f "$TMP_FILE" \
        && echo "[INFO]  Temporary file removed" \
        || {
            echo "[ERROR] Failed to remove temporary file" >&2
            echo "[NOTE]  Please remove it manually: $TMP_FILE"
        }

    echo "[INFO]  Exiting with status code: $1"
    exit "$1"
}

trap 'cleanup $?' EXIT

echo "[INFO]  Performing some operations..."
exit 1
```

/////
////
///

## Redirecting Errors to `stderr`

Standard error (`stderr`) is a file descriptor used to output error messages on Unix-like systems. By default, error messages are displayed on the terminal alongside standard output (`stdout`). Redirecting errors to `stderr` is essential for separating them from regular output, simplifying error identification and management.

/// admonition | Guidelines
    type: info

- **Usage**: <mark>**_ALWAYS_**</mark> use `>&2` to redirect error messages to `stderr`.
- **Reason**: Command-line utilities and scripts expect errors to be redirected to `stderr` for proper error handling and integration with other tools.

///

/// admonition | Example
    type: example

```bash
cd /some/nonexistent/path \
    || {
        echo "Error: Failed to change directory to /some/nonexistent/path" >&2
        exit 1
    }
```

///

## Understanding `set -e`

The `set -e` option in Bash instructs the shell to immediately exit if any command returns a non-zero exit status. This behavior can be useful for ensuring that scripts halt execution upon encountering an error, but it can also lead to unexpected exits if not handled correctly.

/// admonition | Guidelines
    type: info

- **Use Carefully**: Use `set -e` judiciously. Avoid using it in scripts where premature exits could cause issues.
    - **Reason**: `set -e` can lead to unexpected script exits if handled incorrectly.
- **Test Thoroughly**: Due to potentially unexpected behaviors, thoroughly test scripts with `set -e` under various conditions to ensure they behave as expected without premature exits unless justified.

///

/// admonition | Risks of Using `set -e`
    type: warning

- **Unintended Exits**: `set -e` can cause premature script termination if a command fails, even when the failure is expected or handled, leading to incomplete execution.
- **Limited Control**: `set -e` applies a blanket error-handling approach, which can be overly restrictive in scenarios where inevitable failures are expected or require specific handling.
- **Debugging Challenges**: The immediate exit behavior of `set -e` can make it harder to identify the exact point of failure, complicating debugging.
- **Compatibility Issues**: `set -e` may behave differently across various shell environments or under certain conditions (e.g., subshells, pipelines), potentially leading to inconsistencies in script execution.

///


/// details | Examples
    type: example
//// tab | Unexpected Exit

<!-- TODO: Come up with some good examples for this. -->

```bash

```

////
///
