# Proper Error Handling

Like any programming language, error handling in Bash ensures a program functions as intended. Proper error handling ensures a script behaves predictably, provides useful feedback, and avoids unexpected behavior.

This section covers essential practices for handling errors in Bash, including checking command success, using `trap` for signal handling, redirecting errors to `stderr`, and understanding `set -e`.

## Checking Command Success

Commands like `cd`, `rm`, or `mv` can fail for various reasons, such as incorrect paths, insufficient permissions, or missing files. Failing to check the success of these commands can lead to unintended consequences, such as deleting the wrong files or modifying the wrong directories.

/// admonition | Guidelines
    type: info

//// tab | Conditional Checks

- **Guideline**: <mark>**_ALWAYS_**</mark> follow commands whose potential to fail could cause problems for the rest of the script with a conditional check.

///// admonition | Example
    type: example

_Checking the success of the `cd` command, before removing a file:_

```bash
cd /some/path || exit 1
rm file
```

/////
////
//// tab | Error Messages for Clarity

- **Guideline**: When a command fails, provide a clear error message indicating what went wrong.
- **Reason**: By providing descriptive error messages, you make it easier to identify the cause of the failure.

///// admonition | Example
    type: example

_Providing an error message when the `cd` command fails:_

```bash
cd /some/path || { echo "Failed to change directory" && exit 1 }
rm file
```

/////
////
///

## Using `trap` for Signal Handling

Signal handling in Bash involves capturing and responding to signals sent to the script. Signals can be generated by the system or user actions, such as pressing ++ctrl+'C'++ to interrupt a script or sending a termination signal with the `kill` command.

/// admonition | Guidelines
    type: info

//// tab | Cleanup Operations

- **Guideline**: <mark>**_Consider_**</mark> using `trap` to define cleanup operations or other necessary actions that should occur before a script exits naturally or unexpectedly.
- **Reason**: Without `trap`, it's challenging to ensure that files or other resources are properly cleaned up before the script exits.

///// admonition | Example
    type: example

_Using `trap` to remove a temporary file when the script exits:_

```bash
trap 'rm -f /tmp/mytempfile' EXIT

touch /tmp/mytempfile
echo "Temporary file created."
exit 0
```

/////
////
//// tab | Functions for Complex Trapping Logic

- **Guideline**: For more complex signal handling, define a function that performs all necessary actions and then invoke this function in your `trap` command.
- **Reason**: Functions help keep your trapping logic organized and manageable, especially when dealing with multiple signals or complex cleanup tasks.

///// admonition | Example
    type: example

_Defining a cleanup function and using it with `trap`:_

```bash
cleanup() {
    echo "Cleaning up..."
    if [[ $1 == "error" ]]; then
        echo "An error occurred. Additional cleanup may be needed."
        ...
    elif [[ $1 == "exit" ]]; then
        echo "Script exiting normally."
        ...
    fi

    exit "$2"
}

trap 'cleanup "error" "$?"' ERR
trap 'cleanup "exit" "$?"' EXIT
```

/////
////
///

### Common Signals to Trap

- **SIGINT**: Interrupt signal, typically sent from the keyboard (++ctrl+'C'++), indicating that a process should cease operation.
- **SIGQUIT**: Quit signal, often triggered by (++ctrl+'\'++), causing a process to terminate and create a core dump.
- **SIGTERM**: Termination signal, commonly sent by the `kill` command to request a graceful shutdown.


## Redirecting Errors to `stderr`

On Unix-like systems, standard error (`stderr`) is a file descriptor used to output error messages. By default, error messages are displayed on the terminal alongside standard output (`stdout`). Redirecting error messages to `stderr` is essential for separating error output from regular output, making it easier to identify and handle errors.

/// admonition | Guidelines
    type: info

- **Guideline**: <mark>**_ALWAYS_**</mark> use `>&2` to redirect error messages to `stderr`.
    - **Reason**: Allows for the independent redirection of errors from standard output, which is beneficial in command-line utilities and scripts integrated into larger pipelines.
- **Descriptive Messages**: Provide clear and descriptive error messages when redirecting to `stderr`.
    - **Reason**: Descriptive error messages help users understand what went wrong and how to resolve the issue.

///

/// admonition | Example
    type: example

_Redirecting an error message to `stderr`:_

```bash
cd /some/nonexistent/path || {
    echo "Error: Failed to change directory to /some/nonexistent/path" >&2
    exit 1
}
```

///

## Understanding `set -e`

The `set -e` option in Bash instructs the shell to immediately exit if any command returns a non-zero exit status. This behavior can be useful for ensuring that scripts halt execution upon encountering an error, but it can also lead to unexpected exits if not handled correctly.

/// admonition | Guidelines
    type: info

- **Use Carefully**: Use `set -e` judiciously, as it can lead to unexpected script exits if not handled correctly. Avoid using it in scripts where premature exits could cause issues.
- **Test Thoroughly**: Due to the potential for unexpected behavior, thoroughly test scripts with `set -e` under various conditions to ensure that they behave as expected without premature exits unless justified.

///

/// admonition | Risks of Using `set -e`
    type: warning

- **Unintended Exits**: Scripts with `set -e` may exit prematurely if a command fails, even if the failure is expected or handled internally. This behavior can lead to incomplete or incorrect script execution.
- **Complex Conditions**: In scripts with complex command sequences or conditional logic, `set -e` might not behave as expected, causing the script to exit unexpectedly. This can make debugging more challenging.
- **Limited Control**: `set -e` provides a blanket approach to error handling, which may not be suitable for all scenarios. It can be overly restrictive in scripts where certain commands are expected to fail or require specific handling.
- **Debugging Challenges**: Scripts with `set -e` can be harder to debug, as the exact point of failure might not be immediately apparent due to the script's immediate exit behavior.
- **Compatibility Concerns**: `set -e` might not work as expected in all environments or with all commands, potentially leading to inconsistencies in script behavior.

///


/// details | Examples
    type: example
//// tab | Basic Use of `set -e`

_Using `set -e` to exit on command failure:_

```bash
#!/bin/bash
set -e
echo "Creating directory..."
mkdir /some/newdir
echo "Directory created."
cd /some/newdir
echo "Changed directory."
```

**Advantage:** Ensures that the script exits immediately if any command fails, preventing further execution.

////
//// tab | Combining `set -e` with Explicit Error Handling

_Combining `set -e` with error checks:_

```bash
#!/bin/bash
set -e
echo "Creating directory..."
mkdir /some/newdir || { echo "Failed to create directory"; exit 1; }
echo "Directory created."
cd /some/newdir || { echo "Failed to change directory"; exit 1; }
echo "Changed directory."
```

**Advantage:** Provides explicit error messages and handling for crucial commands while benefiting from the protection of `set -e`.

////
//// tab | Testing `set -e` Thoroughly

_Testing scripts with `set -e`_

```bash
#!/bin/bash
set -e
echo "Creating directory..."
mkdir /some/newdir
echo "Directory created."
false  # Simulate a command failure
echo "This will not be printed due to set -e"
```

**Advantage:** Ensures the script exits at the point of failure, helping to identify and manage errors early.

////
//// tab | Handling Complex Conditions with `set -e`

_Managing complex operations with `set -e` and explicit error handling:_

```bash
#!/bin/bash
set -e
echo "Starting complex operation..."
{ command1 && command2; } || { echo "Complex operation failed"; exit 1; }
echo "Complex operation succeeded."
```

**Advantage:** Manages complex command sequences with explicit error handling, ensuring clarity on success and failure points.

////
///
