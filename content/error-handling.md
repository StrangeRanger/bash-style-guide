# Proper Error Handling

Like any programming language, error handling in Bash ensures a program functions as intended. Proper error handling ensures a script behaves predictably, provides useful feedback, and avoids unexpected behaviors.

This section covers essential practices for handling errors in Bash, including checking command success, using `trap` for signal handling, redirecting errors to `stderr`, and understanding `set -e`.

## Checking Command Success

Commands like `cd`, `rm`, or `mv` can fail for various reasons, such as incorrect paths, insufficient permissions, or missing files. Failing to check the success of these commands can lead to unintended consequences, such as deleting the wrong files or modifying the wrong directories.

/// admonition | Guidelines
    type: info
//// tab | Conditional Checks

- **Guideline**: <mark>**_ALWAYS_**</mark> follow commands whose potential to fail could cause problems for the rest of the script, with a conditional check.

///// admonition | Example
    type: example

_Checking the success of `cd` before removing a file:_

```bash
cd /some/path || exit 1
rm file
```

/////
////
//// tab | Error Messages for Clarity

- **Guideline**: When a command fails, provide a clear error message indicating what went wrong.

///// admonition | Example
    type: example

_Providing an error message when `cd` fails:_

```bash
cd /some/path || { echo "Failed to change directory" && exit 1 }
rm file
```

/////
////
///

## Using `trap` for Signal Handling

Signal handling in Bash involves capturing and responding to signals sent to or by the script. Signals can be generated by the system or user actions, such as pressing ++ctrl+'C'++ to interrupt a script or sending a termination signal with the `kill` command.

/// admonition | Guidelines
    type: info
//// tab | Cleanup Operations

- **Guideline**: <mark>**_CONSIDER_**</mark> using `trap` to define cleanup operations or other necessary actions that should occur before a script exits naturally or unexpectedly.
- **Reason**: Without `trap`, ensuring that files or other resources are properly cleaned up before the script exits can be challenging.

///// admonition | Example
    type: example

_Using `trap` to remove a temporary file when the script exits:_

```bash
trap 'rm -f /tmp/mytempfile' EXIT

touch /tmp/mytempfile
echo "Temporary file created."
exit 0
```

/////
////
//// tab | Functions for Complex Trapping Logic

- **Guideline**: For more complex signal handling, define a function that performs all necessary actions and then invoke this function in your `trap` command.
- **Reason**: Functions help keep your trapping logic organized and manageable, especially when dealing with multiple signals or complex cleanup tasks.

///// admonition | Example
    type: example

_Defining a cleanup function and using it with `trap`:_

```bash
cleanup() {
    echo "Cleaning up..."
    if [[ $1 == "error" ]]; then
        echo "An error occurred. Additional cleanup may be needed."
        ...
    elif [[ $1 == "exit" ]]; then
        echo "Script exiting normally."
        ...
    fi

    exit "$2"
}

trap 'cleanup "error" "$?"' ERR
trap 'cleanup "exit" "$?"' EXIT
```

/////
////
///

### Common Signals

<!-- TODO: Ensure the wording and signal definitions are correct. -->

- **SIGINT**: Interrupt signals, typically sent from the keyboard (++ctrl+'C'++), indicate that a process should cease operation.
- **SIGQUIT**: Quit signals, often triggered by (++ctrl+'\\'++), cause a process to terminate and create a core dump.
- **SIGTERM**: Termination signals are commonly sent by the `kill` command to request a graceful shutdown.
- **SIGHUP**: A hangup signal is sent when a terminal is closed or a session leader exits. It is often used to reload configurations in daemon processes.
- **SIGKILL**: The kill signal forces the immediate termination of a process; it cannot be trapped or ignored.
- **SIGALRM**: An alarm signal triggered by the expiration of a timer set with `alarm` is often used to implement timeouts.
- **SIGCHLD**: A child signal is sent to a parent process when a child process exits or is stopped. It is used to prevent zombie processes from reaping children.
- **SIGPIPE**: A pipe signal occurs when a process writes to a pipe without a reader, usually indicating a broken pipe error.
- **SIGUSR1**: User-defined signal 1, reserved for custom purposes defined by the user.
- **SIGUSR2**: User-defined signal 2, another signal reserved for user-defined custom behavior.
- **SIGSTOP**: Stop signal, pauses a process's execution; this signal cannot be trapped.
- **SIGCONT**: Continue signal, resumes the execution of a paused process.


## Redirecting Errors to `stderr`

Standard error (`stderr`) is a file descriptor used to output error messages on Unix-like systems. By default, error messages are displayed on the terminal alongside standard output (`stdout`). Redirecting errors to `stderr` is essential for separating them from regular output, simplifying error identification and management.

/// admonition | Guidelines
    type: info

- **Guideline**: <mark>**_ALWAYS_**</mark> use `>&2` to redirect error messages to `stderr`.
    - **Reason**: Command-line utilities and scripts expect errors to be redirected to `stderr` for proper error handling and integration with other tools.
- **Descriptive Messages**: Provide clear and descriptive error messages when redirecting to `stderr`.
    - **Reason**: Descriptive error messages help users understand what went wrong and how to resolve the issue.

///

/// admonition | Example
    type: example

_Redirecting an error message to `stderr`:_

```bash
cd /some/nonexistent/path || {
    echo "Error: Failed to change directory to /some/nonexistent/path" >&2
    exit 1
}
```

///

## Understanding `set -e`

The `set -e` option in Bash instructs the shell to immediately exit if any command returns a non-zero exit status. This behavior can be useful for ensuring that scripts halt execution upon encountering an error, but it can also lead to unexpected exits if not handled correctly.

/// admonition | Guidelines
    type: info

- **Use Carefully**: Use `set -e` judiciously, as it can lead to unexpected script exits if handled incorrectly. Avoid using it in scripts where premature exits could cause issues.
- **Test Thoroughly**: Due to the potential for unexpected behavior, thoroughly test scripts with `set -e` under various conditions to ensure that they behave as expected without premature exits unless justified.

///

/// admonition | Risks of Using `set -e`
    type: warning

- **Unintended Exits**: `set -e` can cause premature script termination if a command fails, even when the failure is expected or handled, leading to incomplete execution.
- **Complex Conditions**: In scripts with complex logic, `set -e` may cause unexpected exits in scenarios where commands are expected to fail, complicating debugging.
- **Limited Control**: `set -e` applies a blanket error-handling approach, which can be overly restrictive in scenarios where certain failures are expected or require specific handling.
- **Debugging Challenges**: The immediate exit behavior of `set -e` can make it harder to identify the exact point of failure, complicating debugging.
- **Compatibility Issues**: `set -e` may behave differently across various shell environments or under certain conditions (e.g., subshells, pipelines), potentially leading to inconsistencies in script execution.

///


/// details | Examples
    type: example
//// tab | Basic Use of `set -e`

_Using `set -e` to exit on command failure:_

```bash
#!/bin/bash
set -e
echo "Creating directory..."
mkdir /some/newdir
echo "Directory created."
cd /some/newdir
echo "Changed directory."
```

**Advantage:** Ensures that the script exits immediately if any command fails, preventing further execution.

////
//// tab | Combining `set -e` with Explicit Error Handling

_Combining `set -e` with error checks:_

```bash
#!/bin/bash
set -e
echo "Creating directory..."
mkdir /some/newdir || { echo "Failed to create directory"; exit 1; }
echo "Directory created."
cd /some/newdir || { echo "Failed to change directory"; exit 1; }
echo "Changed directory."
```

**Advantage:** Provides explicit error messages and handling for crucial commands while benefiting from the protection of `set -e`.

////
//// tab | Testing `set -e` Thoroughly

_Testing scripts with `set -e`_

```bash
#!/bin/bash
set -e
echo "Creating directory..."
mkdir /some/newdir
echo "Directory created."
false  # Simulate a command failure
echo "This will not be printed due to set -e"
```

**Advantage:** Ensures the script exits at the point of failure, helping to identify and manage errors early.

////
//// tab | Handling Complex Conditions with `set -e`

_Managing complex operations with `set -e` and explicit error handling:_

```bash
#!/bin/bash
set -e
echo "Starting complex operation..."
{ command1 && command2; } || { echo "Complex operation failed"; exit 1; }
echo "Complex operation succeeded."
```

**Advantage:** Manages complex command sequences with explicit error handling, ensuring clarity on success and failure points.

////
///
